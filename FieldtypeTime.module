<?php declare(strict_types=1);

namespace ProcessWire;

use ProcessWire\Page;
use ProcessWire\Field;
use ProcessWire\InputfieldTime;

/**
 * ProcessWire Time Fieldtype
 *
 * Field that stores a time value.
 * The underlying MySQL type allows a range from '-838:59:59' to '838:59:59'. The hours part may be so large
 * because the TIME type can be used not only to represent a time of day (which must be less than 24 hours), but also
 * elapsed time or a time interval between two events (which may be much greater than 24 hours, or even negative).
 *
 */
class FieldtypeTime extends FieldtypeText
{
    const MYCLASS = 'FieldtypeTime';

    public static function getModuleInfo()
    {
        return [
            'name'      => self::MYCLASS,
            'title'     => __('Time'),
            'summary'   => __('Stores a time'),
            'version'   => '2.0.0',
            'permanent' => false,
            'autoload'  => false,
            'singular'  => false,
            'author'    => 'Netcarver',
            'requires'  => [
                'ProcessWire>3.0.33',
                'PHP>=7.2.0',
            ],
        ];
    }


    static protected $formats = null;



    /**
     * Access our defined time formats & descriptions.
     */
    static public function getTimeFormats($format = null)
    {
        if (null === self::$formats) {
            self::$formats = [
                'HH24'      => [
                    'desc' => __('Hours (0-24)'),
                    'placeholder' => '00',
                ],
                'HH24MM'    => [
                    'desc' => __('Hours (0-24) and minutes (00-59)'),
                    'placeholder' => '00:00',
                ],
                'HH24MMSS'  => [
                    'desc' => __('Hours (0-24), minutes (00-59), and seconds (00-59)'),
                    'placeholder' => '00:00:00',
                ],
                'HHH'        => [
                    'desc' => __('Hours (Integer 0-800)'),
                    'placeholder' => '000',
                ],
                'HHHMM'      => [
                    'desc' => __('Hours (0-800) and minutes (00-59)'),
                    'placeholder' => '000:00',
                ],
                'HHHMMSS'    => [
                    'desc' => __('Hours (0-800), minutes (00-59), and seconds (00-59)'),
                    'placeholder' => '000:00:00',
                ],
                'MMM'         => [
                    'desc' => __('Minutes (Integer)'),
                    'placeholder' => '00',
                ],
                'SSS'         => [
                    'desc' => __('Seconds (Integer)'),
                    'placeholder' => '00',
                ],
                'MMSS'       => [
                    'desc' => __('Minutes (00-59) and seconds (00-59)'),
                    'placeholder' => '00:00',
                ],
            ];
        }

        if (is_string($format) && !empty($format) && array_key_exists($format, self::$formats)) {
            return self::$formats[$format];
        }

        return self::$formats;
    }



    /**
     * Returns an array of time parts.
     */
    public static function getTimeParts($t = null)
    {
        $parts = [
            'sign'  => '',
            'hours' => '00',
            'mins'  => '00',
            'secs'  => '00',
        ];

        if (is_string($t)) {
            $t = trim($t);
            $t = preg_replace('[^\d:-]', '', $t);
            if (false !== strpos($t, ':')) {
                $p = explode(':', $t);
                if (3 === count($p)) {
                    $parts['secs'] = $p[2];
                    $parts['mins'] = $p[1];
                    if ('-' === substr($p[0], 0, 1)) {
                        $parts['sign'] = '-';
                        $p[0] = ltrim($p[0], '-');
                    }
                    if (strlen($p[0])) {
                        $parts['hours'] = $p[0];
                    }
                }
            }
        }

        return $parts;
    }



    /**
     * Converts an array of time parts into a DB time string.
     */
    public static function partsToDBTime(array $parts, string $glue=':') : string
    {
        $sign = array_shift($parts);
        $dbtime = $sign . implode($glue, $parts);

        return $dbtime;
    }



    /**
     * Checks the hour part is within the 24 hour range.
     */
    public static function is24($val) : bool
    {
        $val = (int) $val;

        $lower_ok = $val >= 0;
        $upper_ok = $val < 24;

        return $lower_ok && $upper_ok;
    }



    /**
     * Checks the $val is within the range 0-59 inclusive.
     */
    public static function is60($val) : bool
    {
        $val = (int) $val;

        $lower_ok = $val >= 0;
        $upper_ok = $val < 60;

        return $lower_ok && $upper_ok;
    }



    public static function limit($val, $max, $min=0)
    {
        $val = (int) $val;
        $min = (int) $min;
        $max = (int) $max;

        if ($max <= $min) {
            $max = $min + 1;
        }

        $lower_ok = $val >= $min;
        $upper_ok = $val <  $max;

        if (!$lower_ok) {
            return $min;
        }

        if (!$upper_ok) {
            return $max-1;
        }

        $val = sprintf('%02d', $val);

        return $val;
    }



    /**
     * Given a format, converts the given $time to it.
     */
    static public function timeToFormattedString($time, string $format, int $use_colons) : string
    {
        if (empty($time)) {
            $time = '';
        }

        if (empty($format)) {
            $format = 'HH24MMSS';
        }

        $parts = self::getTimeParts($time);
        $val   = $time;

        $glue = ($use_colons) ? ':' : '';


        switch ($format) {
        case 'SSS':
            $val  = (int) $parts['secs'];
            $val += $parts['mins']  *   60;
            $val += $parts['hours'] * 3600;
            break;

        case 'MMM':
            $val  = $parts['mins'];
            $val += $parts['hours'] * 60;
            break;

        case 'HHH':
            $val = $parts['hours'] * 1;
            break;

        case 'HH24':
            if (!self::is24($parts['hours'])) {
                return '';
            }
            $val = $parts['hours'];
            break;

        case 'HH24MM':
            if (!self::is24($parts['hours']) || !self::is60($parts['mins'])) {
                return '';
            }
            $val = $parts['hours'] . $glue . $parts['mins'];
            break;

        case 'HHHMM':
            if (!self::is60($parts['mins'])) {
                return '';
            }
            $val = $parts['hours'] . $glue . $parts['mins'];
            break;

        case 'HH24MMSS':
            if (!self::is24($parts['hours']) || !self::is60($parts['mins']) || !self::is60($parts['secs'])) {
                return '';
            }
            $val = $parts['hours'] . $glue . $parts['mins'] . $glue . $parts['secs'];
            break;

        case 'HHHMMSS':
            if (!self::is60($parts['mins']) || !self::is60($parts['secs'])) {
                return '';
            }
            $val = $parts['hours'] . $glue . $parts['mins'] . $glue . $parts['secs'];
            break;

        case 'MMSS':
            if (!self::is60($parts['mins']) || !self::is60($parts['secs'])) {
                return '';
            }
            $val = $parts['mins'] . $glue . $parts['secs'];
            break;
        }

        if (is_int($val)) {
            $val = (string) $val;
        }

        return $val;
    }



    /**
     * Given an expected format convert the given string to DB time string
     *
     * @param string $str Time string
     * @param string $format Expected format of the time string
     * @return string
     */
    static public function formattedStringToTime($str, $format)
    {
        if (empty($str)) {
            $str = '';
        }

        if (empty($format)) {
            $format = 'HH24MMSS';
        }

        $str = preg_replace('[^\d:-]', '', $str);
        $parts = self::getTimeParts();

        if (false === strpos($str, ':')) {
            // Try splitting every 2 chars from the right...
            $bits = str_split(strrev($str), 2);
            $bits = array_reverse(array_map('strrev', $bits));
        } else {
            $bits = explode(':', $str);
        }
        $count = count($bits);

        /**
         * Inject extra bits for mins and seconds as needed...
         */
        switch ($count) {
        case 2:
            $bits[] = '00';
        case 1:
            $bits[] = '00';
            break;
        }

        switch ($format) {
        case 'SSS':
            $val = (int) $str;
            $parts['hours'] = $val / 3600;
            $parts['mins']  = $val / 60 % 60;
            $parts['secs']  = $val % 60;
            break;

        case 'MMM':
            $val = (int) $str;
            $val *= 60;
            $parts['hours'] = $val / 3600;
            $parts['mins']  = $val / 60 % 60;
            break;

        case 'HHH':
            $parts['hours'] = (int) $str;
            break;

        case 'HH24':
            $parts['hours'] = self::limit($str, 24);
            break;

        case 'HH24MM':
            $parts['hours'] = self::limit($bits[0], 24);
            $parts['mins']  = self::limit($bits[1], 60);
            break;

        case 'HH24MMSS':
            $parts['hours'] = self::limit($bits[0], 24);
            $parts['mins']  = self::limit($bits[1], 60);
            $parts['secs']  = self::limit($bits[2], 60);
            break;

        case 'HHHMM':
            $parts['hours'] = $bits[0];
            $parts['mins']  = self::limit($bits[1], 60);
            break;

        case 'HHHMMSS':
            $parts['hours'] = $bits[0];
            $parts['mins']  = self::limit($bits[1], 60);
            $parts['secs']  = self::limit($bits[2], 60);
            break;

        case 'MMSS':
            $parts['mins']  = self::limit($bits[0], 60);
            $parts['secs']  = self::limit($bits[1], 60);
            break;
        }

        return self::partsToDBTime($parts);
    }



    /**
     *
     */
    public function init()
    {
        parent::init();
        $this->allowTextFormatters(false);
    }



    /**
     *
     */
    public function getInputfield(Page $page, Field $field) : InputfieldTime
    {

        $format = $field->format;

        $inputfield = $this->modules->get('InputfieldTime');
        $inputfield->class = $this->className();
        $inputfield->attr('format', $format);

        $f_info = self::getTimeFormats($format);

        $inputfield->attr('title', $f_info['desc']);
        $inputfield->attr('placeholder', $f_info['placeholder']);
        return $inputfield;
    }



    /**
     * Sanitize value
     */
    public function sanitizeValue(Page $page, Field $field, $value)
    {
        return $this->_sanitizeValue($value);
    }



    /**
     * Common sanitise routine...
     * Sanitize a value assumed to be a MySQL time format...
     */
    protected function _sanitizeValue(string $value) : string
    {
        if (empty($value)) {
            return '';
        }

        return preg_replace('#[^\d:-]#', '', $value);
    }



    /**
     * Match a date/time value in the database, as used by PageFinder
     */
    public function getMatchQuery($query, $table, $subfield, $operator, $value)
    {
        $value = $this->_sanitizeValue($value);

        $database = $this->wire('database');
        if ($database->isOperator($operator)) {
            $table = $database->escapeTable($table);
            $subfield = $database->escapeCol($subfield);
            $value = $database->escapeStr($value);
            $query->where("$table.{$subfield}{$operator}'$value'");
        }

        return $query;
    }



    /**
     *
     */
    public function getDatabaseSchema(Field $field)
    {
        $schema = parent::getDatabaseSchema($field);
        $schema['data'] = 'time NOT NULL';
        unset($schema['keys']['data_exact']);
        $schema['keys']['data'] = 'KEY data (data)';
        return $schema;
    }



    /**
     * Convert value from time to formatted string
     */
    public function ___sleepValue(Page $page, Field $field, $value)
    {
        return $this->formattedStringToTime($value, $field->format);
    }



    /**
     * Convert value from DB time field to formatted string
     */
    public function ___wakeupValue(Page $page, Field $field, $value)
    {
        return $this->timeToFormattedString($value, $field->format, $field->useColons);
    }



    /**
     * Field configuration screen
     */
    public function ___getConfigInputfields(Field $field)
    {
        $inputfields = parent::___getConfigInputfields($field);

        $f = $this->modules->get('InputfieldSelect');
        $f->attr('name', 'format');
        $f->label = $this->_('Time Format');
        foreach (self::getTimeFormats() as $format => $info) {
            $f->addOption($format, $info['desc']);
            if(strpos($field->format ?? '', $format) !== false) {
                $f->attr('value', $format);
            }
        }
        $inputfields->add($f);

        $f = $this->modules->get('InputfieldCheckbox');
        $f->attr('name', 'useColons');
        $f->label = $this->_('Use colons');
        $f->description = $this->_('When checked, colons will be output between the hours, minutes and seconds.');
        $f->attr('value', 1);
        if ($field->useColons) {
            $f->attr('checked', 'checked');
        }
        $inputfields->append($f);

        return $inputfields;
    }
}
